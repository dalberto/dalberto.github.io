<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>connecting to a remote Docker daemon over SSH | darlin.io</title><meta name=keywords content="docker,ssh"><meta name=description content="Recently, I was working on a project that required connecting to a Docker daemon running on a remote machine. This is a common use case for Docker, and there are a few ways to accomplish it. I will describe the method I used.
motivation Typically, I use Docker on my local machine, but this project upended that workflow.
For my use-case, I needed to interact with a remote daemon because:"><meta name=author content><link rel=canonical href=https://darlin.io/posts/remote-docker-daemon/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b243b7f5b0b102ded02c5f3996163a62b4a5cdacab1ed6480c9b042445d1ae4a.css integrity="sha256-skO39bCxAt7QLF85lhY6YrSlzayrHtZIDJsEJEXRrko=" rel="preload stylesheet" as=style><link rel=icon href=https://darlin.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://darlin.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://darlin.io/favicon-32x32.png><link rel=apple-touch-icon href=https://darlin.io/apple-touch-icon.png><link rel=mask-icon href=https://darlin.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><meta property="og:title" content="connecting to a remote Docker daemon over SSH"><meta property="og:description" content="Recently, I was working on a project that required connecting to a Docker daemon running on a remote machine. This is a common use case for Docker, and there are a few ways to accomplish it. I will describe the method I used.
motivation Typically, I use Docker on my local machine, but this project upended that workflow.
For my use-case, I needed to interact with a remote daemon because:"><meta property="og:type" content="article"><meta property="og:url" content="https://darlin.io/posts/remote-docker-daemon/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-26T08:15:15-05:00"><meta property="article:modified_time" content="2022-12-26T08:15:15-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="connecting to a remote Docker daemon over SSH"><meta name=twitter:description content="Recently, I was working on a project that required connecting to a Docker daemon running on a remote machine. This is a common use case for Docker, and there are a few ways to accomplish it. I will describe the method I used.
motivation Typically, I use Docker on my local machine, but this project upended that workflow.
For my use-case, I needed to interact with a remote daemon because:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://darlin.io/posts/"},{"@type":"ListItem","position":3,"name":"connecting to a remote Docker daemon over SSH","item":"https://darlin.io/posts/remote-docker-daemon/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"connecting to a remote Docker daemon over SSH","name":"connecting to a remote Docker daemon over SSH","description":"Recently, I was working on a project that required connecting to a Docker daemon running on a remote machine. This is a common use case for Docker, and there are a few ways to accomplish it. I will describe the method I used.\nmotivation Typically, I use Docker on my local machine, but this project upended that workflow.\nFor my use-case, I needed to interact with a remote daemon because:","keywords":["docker","ssh"],"articleBody":"Recently, I was working on a project that required connecting to a Docker daemon running on a remote machine. This is a common use case for Docker, and there are a few ways to accomplish it. I will describe the method I used.\nmotivation Typically, I use Docker on my local machine, but this project upended that workflow.\nFor my use-case, I needed to interact with a remote daemon because:\nThe remote daemon had containers running in a bridge docker network, which was not exposed to the local network. I could not restart the remote daemon with the --host flag to expose the daemon to the network because of a long-running process that I did not want to interrupt. A side benefit of this approach was that I was able to use my local tooling, including my IDE, to interact with the remote daemon. This enabled a faster feedback loop as the remote machine was fairly bare-bones.\nthe plan The remote docker daemon runs using a Unix domain socket by default. As mentioned, restarting the demon was not an option.\nThus, the rough plan was to:\nStart an SSH tunnel to the remote machine. Instruct my local Docker CLI to use the SSH tunnel as a proxy. the solution First, I needed to establish an SSH tunnel to the remote machine.\nI ran into a few issues doing so, but finally found that the following options needed to be enabled in sshd_config on the remote machine:\nAllowTcpForwarding yes GatewayPorts yes I restarted the remote/server SSH daemon after making these changes to sshd_config.\nThen, I established the SSH tunnel with the following command (on the client):\nssh -S none -N -L 2379:/var/run/docker.sock user@remote-machine The -S none flag is used to disable the use of a ControlPath, which is not needed in this case, and was causing problems, as I tried to use the same SSH tunnel for the SSH tunnel and an interactive session 1. The -N flag is used to disable the execution of a remote command; essentially make the session non-interactive, as I would be interacting with the daemon via the Docker CLI. The -L flag is used to specify the local port to forward to the remote socket. In this case, I used port 2379 because it is not a default port for Docker, and thus less likely to conflict with other services. Finally, I configured the Docker CLI to use the SSH tunnel as a proxy:\nBash/Zsh:\nexport DOCKER_HOST=localhost:2379 Fish:\nset -gx DOCKER_HOST localhost:2379 To sanity check the connection, I ran the following command:\ndocker ps future improvements This workflow is good but not great, as it requires two steps, and some context-switching (docker and ssh). In the future, I want to use docker contexts to achieve the same workflow. I could not get this to work out of the box, and I suspect it has to do with reading my SSH configuration.\nI believe this conflict can be avoided by setting ControlPath in my ssh config more appropriately. Presently, my setting consists of only the server address /tmp/ssh-%r@%h:%p, so different commands (eg ssh and docker ) would share the same connection. ↩︎\n","wordCount":"525","inLanguage":"en","datePublished":"2022-12-26T08:15:15-05:00","dateModified":"2022-12-26T08:15:15-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://darlin.io/posts/remote-docker-daemon/"},"publisher":{"@type":"Organization","name":"darlin.io","logo":{"@type":"ImageObject","url":"https://darlin.io/favicon.ico"}}}</script><script async defer data-domain=darlin.io src=https://plausible.io/js/plausible.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://darlin.io accesskey=h title="darlin.io (Alt + H)">darlin.io</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>connecting to a remote Docker daemon over SSH</h1><div class=post-meta><span title='2022-12-26 08:15:15 -0500 -0500'>December 26, 2022</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><p>Recently, I was working on a project that required connecting to a Docker daemon running on a remote machine.
This is a common use case for Docker, and there are a few ways to accomplish it. I will describe the method I used.</p><h2 id=motivation>motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h2><p>Typically, I use Docker on my local machine, but this project upended that workflow.</p><p>For my use-case, I needed to interact with a remote daemon because:</p><ul><li>The remote daemon had containers running in a <a href=https://docs.docker.com/network/bridge/>bridge docker network</a>, which was not exposed to the local network.</li><li>I could not restart the remote daemon with the <a href=https://docs.docker.com/config/daemon/><code>--host</code></a> flag to expose the daemon to the network because of a long-running process that I did not want to interrupt.</li></ul><p>A side benefit of this approach was that I was able to use my <a href=/posts/docker-fish-abbreviations/>local tooling</a>, including my IDE, to interact with the remote daemon. This enabled a faster feedback loop as the remote machine was fairly bare-bones.</p><h2 id=the-plan>the plan<a hidden class=anchor aria-hidden=true href=#the-plan>#</a></h2><p>The remote docker daemon runs using a Unix domain socket by default. As mentioned, restarting the demon was not an option.</p><p>Thus, the rough plan was to:</p><ol><li>Start an SSH tunnel to the remote machine.</li><li>Instruct my local Docker CLI to use the SSH tunnel as a proxy.</li></ol><h2 id=the-solution>the solution<a hidden class=anchor aria-hidden=true href=#the-solution>#</a></h2><p>First, I needed to establish an SSH tunnel to the remote machine.</p><p>I ran into a few issues doing so, but finally found that the following options needed to be enabled in <code>sshd_config</code> on the remote machine:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>AllowTcpForwarding yes
</span></span><span style=display:flex><span>GatewayPorts yes
</span></span></code></pre></div><p>I restarted the remote/server SSH daemon after making these changes to <code>sshd_config</code>.</p><p>Then, I established the SSH tunnel with the following command (on the client):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ssh -S none -N -L 2379:/var/run/docker.sock user@remote-machine
</span></span></code></pre></div><ul><li>The <code>-S none</code> flag is used to disable the use of a <code>ControlPath</code>, which is not needed in this case, and was causing problems, as I tried to use the same SSH tunnel for the SSH tunnel <em>and</em> an interactive session <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</li><li>The <code>-N</code> flag is used to disable the execution of a remote command; essentially make the session non-interactive, as I would be interacting with the daemon via the Docker CLI.</li><li>The <code>-L</code> flag is used to specify the local port to forward to the remote socket. In this case, I used port <code>2379</code> because it is not a default port for Docker, and thus less likely to conflict with other services.</li></ul><p>Finally, I configured the Docker CLI to use the SSH tunnel as a proxy:</p><p>Bash/Zsh:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>export DOCKER_HOST<span style=color:#f92672>=</span>localhost:2379
</span></span></code></pre></div><p>Fish:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>set -gx DOCKER_HOST localhost:2379
</span></span></code></pre></div><p>To sanity check the connection, I ran the following command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><h2 id=future-improvements>future improvements<a hidden class=anchor aria-hidden=true href=#future-improvements>#</a></h2><p>This workflow is good but not <em>great</em>, as it requires two steps, and some context-switching (docker and ssh).
In the future, I want to use <a href=https://docs.docker.com/engine/security/protect-access/>docker contexts</a> to achieve the same workflow. I could not get this to work out of the box, and I suspect it has to do with reading my SSH configuration.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>I believe this conflict can be avoided by setting <code>ControlPath</code> in my ssh config more appropriately. Presently, my setting consists of only the server address <code>/tmp/ssh-%r@%h:%p</code>, so different commands (eg <code>ssh</code> and <code>docker</code> ) would share the same connection.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://darlin.io/tags/docker/>docker</a></li><li><a href=https://darlin.io/tags/ssh/>ssh</a></li></ul><nav class=paginav><a class=next href=https://darlin.io/posts/git-update-one-liner/><span class=title>Next »</span><br><span>my favorite one-liner to update a local git branch</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://darlin.io>darlin.io</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>