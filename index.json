[{"content":"I previously connected to a remote docker daemon using an SSH tunnel . While my solution worked, I wanted to explore a more elegant solution using docker contexts.\nI initially attempted to use docker contexts as-is:\ndocker context create remote --docker \u0026#34;host=ssh://user@remote-machine\u0026#34; And then attempted to use it and perform a sanity check:\ndocker context use remote docker ps However, I received an error like the following:\n# other output sh: docker: command not found After some searching, I was able to get to a solution.\nFirst, I needed to set PermitUserEnvironment to yes in sshd_config on the remote machine. Then, I modified ~/.ssh/environment on the remote machine to include my full PATH variable. Finally, I restarted the remote SSH daemon.\nAfter these tweaks, the previous docker commands succeeded!\nNow, when I want to connect to my remote daemon I simply run:\ndocker context use remote And execute docker and docker compose commands as normal. 🚀\nIn the future, I will surface the current docker context in my shell prompt, so I can easily see which context I am using, similar to how many prompts surface git working state .\n","permalink":"https://darlin.io/posts/remote-docker-daemon-pt-2/","summary":"I previously connected to a remote docker daemon using an SSH tunnel . While my solution worked, I wanted to explore a more elegant solution using docker contexts.\nI initially attempted to use docker contexts as-is:\ndocker context create remote --docker \u0026#34;host=ssh://user@remote-machine\u0026#34; And then attempted to use it and perform a sanity check:\ndocker context use remote docker ps However, I received an error like the following:\n# other output sh: docker: command not found After some searching, I was able to get to a solution.","title":"connecting to a remote Docker daemon over SSH pt2"},{"content":"Recently, I was working on a project that required connecting to a Docker daemon running on a remote machine. This is a common use case for Docker, and there are a few ways to accomplish it. I will describe the method I used.\nmotivation Typically, I use Docker on my local machine, but this project upended that workflow.\nFor my use-case, I needed to interact with a remote daemon because:\nThe remote daemon had containers running in a bridge docker network, which was not exposed to the local network. I could not restart the remote daemon with the --host flag to expose the daemon to the network because of a long-running process that I did not want to interrupt. A side benefit of this approach was that I was able to use my local tooling, including my IDE, to interact with the remote daemon. This enabled a faster feedback loop as the remote machine was fairly bare-bones.\nthe plan The remote docker daemon runs using a Unix domain socket by default. As mentioned, restarting the demon was not an option.\nThus, the rough plan was to:\nStart an SSH tunnel to the remote machine. Instruct my local Docker CLI to use the SSH tunnel as a proxy. the solution First, I needed to establish an SSH tunnel to the remote machine.\nI ran into a few issues doing so, but finally found that the following options needed to be enabled in sshd_config on the remote machine:\nAllowTcpForwarding yes GatewayPorts yes I restarted the remote/server SSH daemon after making these changes to sshd_config.\nThen, I established the SSH tunnel with the following command (on the client):\nssh -S none -N -L 2379:/var/run/docker.sock user@remote-machine The -S none flag is used to disable the use of a ControlPath, which is not needed in this case, and was causing problems, as I tried to use the same SSH tunnel for the SSH tunnel and an interactive session 1. The -N flag is used to disable the execution of a remote command; essentially make the session non-interactive, as I would be interacting with the daemon via the Docker CLI. The -L flag is used to specify the local port to forward to the remote socket. In this case, I used port 2379 because it is not a default port for Docker, and thus less likely to conflict with other services. Finally, I configured the Docker CLI to use the SSH tunnel as a proxy:\nBash/Zsh:\nexport DOCKER_HOST=localhost:2379 Fish:\nset -gx DOCKER_HOST localhost:2379 To sanity check the connection, I ran the following command:\ndocker ps future improvements This workflow is good but not great, as it requires two steps, and some context-switching (docker and ssh). In the future, I want to use docker contexts to achieve the same workflow. I could not get this to work out of the box, and I suspect it has to do with reading my SSH configuration.\nI believe this conflict can be avoided by setting ControlPath in my ssh config more appropriately. Presently, my setting consists of only the server address /tmp/ssh-%r@%h:%p, so different commands (eg ssh and docker ) would share the same connection.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://darlin.io/posts/remote-docker-daemon/","summary":"Recently, I was working on a project that required connecting to a Docker daemon running on a remote machine. This is a common use case for Docker, and there are a few ways to accomplish it. I will describe the method I used.\nmotivation Typically, I use Docker on my local machine, but this project upended that workflow.\nFor my use-case, I needed to interact with a remote daemon because:","title":"connecting to a remote Docker daemon over SSH"},{"content":"When working on a long-lived feature branch, it is often helpful to keep up-to-date with the main branch. The following one-liner typically satisfies that need in my workflow:\ngit pull --autostash --rebase origin main This command is very handy because it:\nPulls the remote branch. Rebases your changes on top of the main branch. Stashes any local changes you may not have committed yet. The equivalent consists of the following commands:\ngit pull origin main git stash git rebase main While executing these commands one by one is not particularly onerous, they require some context-switching that may needlessly disrupt flow.\n","permalink":"https://darlin.io/posts/git-update-one-liner/","summary":"When working on a long-lived feature branch, it is often helpful to keep up-to-date with the main branch. The following one-liner typically satisfies that need in my workflow:\ngit pull --autostash --rebase origin main This command is very handy because it:\nPulls the remote branch. Rebases your changes on top of the main branch. Stashes any local changes you may not have committed yet. The equivalent consists of the following commands:","title":"my favorite one-liner to update a local git branch"},{"content":"Sometimes I want to push my changes quickly and often. The goal is usually to offload some relatively expensive work to a continuous integration server, instead of getting bogged down on my development machine.\nFor example, a change may be validated on my machine, but running a full test suite remotely may be desired. I have been fortunate enough to be on teams with extensive end-to-end test suites, but those suites can sometimes take hours if run locally.\nFor such times, I use the following one-liner:\ngit commit -a --amend --no-edit; git push --force-with-lease Technically, it is two lines in raw shell form, but I use an abbreviation to get around that.\nThis command accomplishes the following:\nCommits all changed tracked files via the -a flag. Amends the previous commit via --amend, so that git does not prompt for a new commit. Reuses the same commit message via --no-edit. Force pushes with lease, a safer alternative to force pushing. It will not overwrite someone else\u0026rsquo;s commit. It will fail if there were changes in the remote branch (e.g. rebase). This combination of flags and commands is very powerful, so it should be used responsibly. Specifically, it is often undesirable to overwrite commits, and atomic commits should be preferred.\n","permalink":"https://darlin.io/posts/git-push-one-liner/","summary":"Sometimes I want to push my changes quickly and often. The goal is usually to offload some relatively expensive work to a continuous integration server, instead of getting bogged down on my development machine.\nFor example, a change may be validated on my machine, but running a full test suite remotely may be desired. I have been fortunate enough to be on teams with extensive end-to-end test suites, but those suites can sometimes take hours if run locally.","title":"my favorite git command for pushing changes fast"},{"content":"summary My favorite command line shell is fish, and one feature I find especially useful is abbreviations.\nAbbreviations are essentially text-expanded shortcuts. Continue reading for a quick rundown.\nbasic usage To add an abbreviation simply call abbr -a WORD EXPANSION, where WORD is the abbreviation and EXPANSION is the expanded command. For example: abbr -a gco git commit.\nTo use it, simply type gco, followed by Space or Enter.\nadvantages Abbreviations can be very useful because:\nThey save time by reducing typing. Moreover, commands that do not require editing can be executed immediately by entering Enter. They are flexible. They expand before execution after pressing Space, so minor changes are trivial. They are easy to set up. They can be defined in the shell without creating new files or updating configuration. They are self-documenting. The exact command executed is displayed. These advantages make them a cost-free abstraction, and a joy to use; they facilitate what I\u0026rsquo;m already doing without introducing overhead.\nmy docker run abbreviation Docker commands are great candidates for being abbreviated because of the long and esoteric options. The following is one of my favorite abbreviations:\nabbr -a dka \u0026#34;docker run --pull=always --volume (pwd):/opt/app -w /opt/app --rm -it\u0026#34; The abbreviated command is designed to run ephemeral containers. I often use this to experiment with small code snippets or packages.\nThis abbreviation assumes the target image will be appended by the user. This command features:\nPulling the latest version of the image specified. Mounts the current directory into the container under /opt/app1. Changes the working directory to /opt/app for convenience. Configures the container for interactive usage (e.g. a shell/interpreter). Removes the container after exit. There\u0026rsquo;s a lot going on there, but I just call dka, followed by the image, to execute this command. ✨ 🍰\nconclusion In the end, Fish abbreviations spark joy because they contribute to a faster feedback loop. I get a trove of functionality with minimal effort.\nThe abbreviated command is in quotes to avoid evaluating (pwd) until the abbreviation is expanded. Ordinarily, abbreviations do not require quotes.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://darlin.io/posts/docker-fish-abbreviations/","summary":"summary My favorite command line shell is fish, and one feature I find especially useful is abbreviations.\nAbbreviations are essentially text-expanded shortcuts. Continue reading for a quick rundown.\nbasic usage To add an abbreviation simply call abbr -a WORD EXPANSION, where WORD is the abbreviation and EXPANSION is the expanded command. For example: abbr -a gco git commit.\nTo use it, simply type gco, followed by Space or Enter.\nadvantages Abbreviations can be very useful because:","title":"a fish shell abbreviation that sparks joy"}]