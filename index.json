[{"content":"When working on a long-lived feature branch, it is often helpful to keep up-to-date with the main branch. The following one-liner typically satisfies that need in my workflow:\ngit pull --autostash --rebase origin main This command is very handy because it:\n Pulls the remote branch. Rebases your changes on top of the main branch. Stashes any local changes you may not have committed yet.  The equivalent consists of the following commands:\ngit pull origin main git stash git rebase main While executing these commands one by one is not particularly onerous, they require some context-switching that may needlessly disrupt flow.\n","permalink":"https://darlin.io/posts/git-update-one-liner/","summary":"When working on a long-lived feature branch, it is often helpful to keep up-to-date with the main branch. The following one-liner typically satisfies that need in my workflow:\ngit pull --autostash --rebase origin main This command is very handy because it:\n Pulls the remote branch. Rebases your changes on top of the main branch. Stashes any local changes you may not have committed yet.  The equivalent consists of the following commands:","title":"my favorite one-liner to update a local git branch"},{"content":"Sometimes I want to push my changes quickly and often. The goal is usually to offload some relatively expensive work to a continuous integration server, instead of getting bogged down on my development machine.\nFor example, a change may be validated on my machine, but running a full test suite remotely may be desired. I have been fortunate enough to be on teams with extensive end-to-end test suites, but those suites can sometimes take hours if run locally.\nFor such times, I use the following one-liner:\ngit commit -a --amend --no-edit; git push --force-with-lease Technically, it is two lines in raw shell form, but I use an abbreviation to get around that.\nThis command accomplishes the following:\n Commits all changed tracked files via the -a flag. Amends the previous commit via --amend, so that git does not prompt for a new commit.  Reuses the same commit message via --no-edit.   Force pushes with lease, a safer alternative to force pushing.  It will not overwrite someone else\u0026rsquo;s commit. It will fail if there were changes in the remote branch (e.g. rebase).    This combination of flags and commands is very powerful, so it should be used responsibly. Specifically, it is often undesirable to overwrite commits, and atomic commits should be preferred.\n","permalink":"https://darlin.io/posts/git-push-one-liner/","summary":"Sometimes I want to push my changes quickly and often. The goal is usually to offload some relatively expensive work to a continuous integration server, instead of getting bogged down on my development machine.\nFor example, a change may be validated on my machine, but running a full test suite remotely may be desired. I have been fortunate enough to be on teams with extensive end-to-end test suites, but those suites can sometimes take hours if run locally.","title":"my favorite git command for pushing changes fast"},{"content":"summary My favorite command line shell is fish, and one feature I find especially useful is abbreviations.\nAbbreviations are essentially text-expanded shortcuts. Continue reading for a quick rundown.\nbasic usage To add an abbreviation simply call abbr -a WORD EXPANSION, where WORD is the abbreviation and EXPANSION is the expanded command. For example: abbr -a gco git commit.\nTo use it, simply type gco, followed by Space or Enter.\nadvantages Abbreviations can be very useful because:\n They save time by reducing typing. Moreover, commands that do not require editing can be executed immediately by entering Enter. They are flexible. They expand before execution after pressing Space, so minor changes are trivial. They are easy to set up. They can be defined in the shell without creating new files or updating configuration. They are self-documenting. The exact command executed is displayed.  These advantages make them a cost-free abstraction, and a joy to use; they facilitate what I\u0026rsquo;m already doing without introducing overhead.\nmy docker run abbreviation Docker commands are great candidates for being abbreviated because of the long and esoteric options. The following is one of my favorite abbreviations:\nabbr -a dka \u0026#34;docker run --pull=always --volume (pwd):/opt/app -w /opt/app --rm -it\u0026#34; The abbreviated command is designed to run ephemeral containers. I often use this to experiment with small code snippets or packages.\nThis abbreviation assumes the target image will be appended by the user. This command features:\n Pulling the latest version of the image specified. Mounts the current directory into the container under /opt/app1. Changes the working directory to /opt/app for convenience. Configures the container for interactive usage (e.g. a shell/interpreter). Removes the container after exit.  There\u0026rsquo;s a lot going on there, but I just call dka, followed by the image, to execute this command. ‚ú® üç∞\nconclusion In the end, Fish abbreviations spark joy because they contribute to a faster feedback loop. I get a trove of functionality with minimal effort.\n  The abbreviated command is in quotes to avoid evaluating (pwd) until the abbreviation is expanded. Ordinarily, abbreviations do not require quotes.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://darlin.io/posts/docker-fish-abbreviations/","summary":"summary My favorite command line shell is fish, and one feature I find especially useful is abbreviations.\nAbbreviations are essentially text-expanded shortcuts. Continue reading for a quick rundown.\nbasic usage To add an abbreviation simply call abbr -a WORD EXPANSION, where WORD is the abbreviation and EXPANSION is the expanded command. For example: abbr -a gco git commit.\nTo use it, simply type gco, followed by Space or Enter.\nadvantages Abbreviations can be very useful because:","title":"a fish shell abbreviation that sparks joy"}]